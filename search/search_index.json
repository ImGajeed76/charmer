{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Charmer","text":"<ul> <li> <p> Simple Integration   Just annotate your functions with <code>@Charm</code></p> </li> <li> <p> Automatic TUI Generation   Create hierarchical menus with zero UI code</p> </li> <li> <p> Charm-Powered   Built on the robust Bubbles and BubbleTea libraries</p> </li> <li> <p> Documentation-Driven   Use annotations to define your CLI structure</p> </li> <li> <p> Focus on Logic   Write your functions, let Charmer handle the UI</p> </li> </ul>"},{"location":"#what-is-charmer","title":"What is Charmer?","text":"<p>Charmer is a Go package that automatically generates Terminal User Interfaces (TUIs) from your Go functions. Powered by Charm libraries, it transforms annotated functions into beautiful, navigable command-line interfaces without the hassle of UI implementation.</p> <p></p>"},{"location":"#why-use-charmer","title":"Why Use Charmer?","text":"<p>Developing beautiful terminal interfaces typically requires extensive UI code. Charmer eliminates this burden by automatically generating interactive TUIs from your Go functions, allowing you to focus on your application's core functionality.</p> <pre><code>package charms\n\nimport \"fmt\"\n\n// @Charm\n// @Title Greet User\n// @Description\n// # Greet User\n// This charm greets the user by name.\nfunc GreetUser(name string) {\n    fmt.Printf(\"Hello, %s! Welcome to Charmer!\\n\", name)\n}\n</code></pre> <p>Just add annotations, and Charmer generates the rest!</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#install-charmer","title":"Install Charmer","text":"<pre><code>go get github.com/ImGajeed76/charmer@latest\n</code></pre> <p>Note: You maybe have to run <code>go mod tidy</code> to update your <code>go.mod</code> file after installing Charmer.</p>"},{"location":"#create-your-first-charm","title":"Create Your First Charm","text":"<pre><code>//go:generate go run github.com/ImGajeed76/charmer/tools/generate\n\npackage main\n\nimport (\n    \"your-project/internal/registry\"\n    \"github.com/ImGajeed76/charmer/pkg/charmer\"\n)\n\nfunc main() {\n    charmer.Run(registry.RegisteredCharms)\n}\n</code></pre>"},{"location":"#generate-run","title":"Generate &amp; Run","text":"<pre><code>go generate\ngo run main.go\n</code></pre> <p>Tip: Instead of running <code>go run main.go</code>, run <code>go build</code> to create a standalone binary and execute it in your favorite terminal.</p>"},{"location":"#development-status","title":"Development Status","text":"<p>Early Alpha Stage</p> <p>This project is currently in early development. Features and APIs may change significantly. The current version might not be fully functional as package publishing is still being configured.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the GNU General Public License v3.0.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<ul> <li>Built with \u2764\ufe0f in Switzerland by ImGajeed76</li> <li>Powered by the amazing Charm libraries</li> </ul> <p>Purpose</p> <p>Simplifying the creation of beautiful terminal utility applications, one function at a time.</p>"},{"location":"changelog/","title":"Charmer Changelog","text":"<p>No Changelog Available</p> <p>Currently there are no changelog entries available. For a complete change history,  please check this GitHub comparison link.</p>"},{"location":"contributing/","title":"Contributing to Charmer","text":"<p>Thank you for your interest in contributing to Charmer! This document provides guidelines and information for contributors who want to help improve this Go-based TUI generator.</p>"},{"location":"contributing/#a-note-from-the-creator","title":"\ud83d\udcad A Note from the Creator","text":"<p>Hey there! I'm ImGajeed76, the creator of Charmer. I want to be upfront with you: I'm not perfect, and neither is this code. Like any developer, I make mistakes, and there's always room for improvement in the codebase. I believe in continuous learning and getting better with each iteration.</p> <p>If you find issues, have suggestions for better implementations, or see ways to improve the code structure - please don't hesitate to speak up! I'm here to learn and grow alongside this project, and I value every contribution and piece of feedback.</p> <p>Remember: perfect code doesn't exist, but better code does. Let's work together to make Charmer better, one commit at a time.</p>"},{"location":"contributing/#ways-to-contribute","title":"\ud83c\udf1f Ways to Contribute","text":"<p>There are many ways you can contribute to Charmer:</p> <ol> <li>Code Contributions: Implement new features or fix bugs</li> <li>Documentation: Improve existing docs or write new guides</li> <li>Bug Reports: Submit detailed bug reports</li> <li>Feature Requests: Suggest new features or improvements</li> <li>Examples: Create example implementations</li> <li>Testing: Write tests and identify edge cases</li> </ol>"},{"location":"contributing/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24 or higher</li> <li>Basic understanding of Go programming</li> <li>Basic familiarity with Charm libraries (If you want to improve TUI)</li> <li>Understanding of TUI (Terminal User Interface) concepts (If you want to improve TUI)</li> </ul>"},{"location":"contributing/#setting-up-your-development-environment","title":"Setting Up Your Development Environment","text":"<ol> <li>Fork the repository</li> <li>Clone your fork:    <pre><code>git clone https://github.com/YOUR_USERNAME/charmer.git\ncd charmer\n</code></pre></li> <li>Add the upstream remote:    <pre><code>git remote add upstream https://github.com/ImGajeed76/charmer.git\n</code></pre></li> <li>Install dependencies:    <pre><code>go mod download\n</code></pre></li> </ol>"},{"location":"contributing/#development-workflow","title":"\ud83d\udcdd Development Workflow","text":"<ol> <li> <p>Create a Branch:    <pre><code>git checkout -b feature/your-feature-name\n# or\ngit checkout -b fix/your-fix-name\n</code></pre></p> </li> <li> <p>Make Your Changes:</p> <ul> <li>Follow the Go coding standards</li> <li>Keep your changes focused and atomic</li> <li>Add tests for new functionality</li> <li>Update documentation as needed</li> </ul> </li> <li> <p>Test Your Changes:    <pre><code>go test ./...\ngo generate\n</code></pre></p> </li> <li> <p>Commit Your Changes:    <pre><code>git commit -m \"type: brief description of changes\"\n</code></pre>    Commit message types:</p> <ul> <li><code>feat</code>: New feature</li> <li><code>fix</code>: Bug fix</li> <li><code>docs</code>: Documentation changes</li> <li><code>test</code>: Adding or modifying tests</li> <li><code>refactor</code>: Code refactoring</li> <li><code>style</code>: Formatting changes</li> <li><code>chore</code>: Maintenance tasks</li> </ul> </li> <li> <p>Push and Create a Pull Request:    <pre><code>git push origin your-branch-name\n</code></pre></p> </li> </ol>"},{"location":"contributing/#code-style-guidelines","title":"\ud83c\udfa8 Code Style Guidelines","text":""},{"location":"contributing/#go-code","title":"Go Code","text":"<ul> <li>Follow the standard Go formatting guidelines</li> <li>Use <code>gofmt</code> to format your code</li> <li>Follow idiomatic Go practices</li> <li>Use meaningful variable and function names</li> <li>Add comments for non-obvious code sections</li> </ul>"},{"location":"contributing/#annotations","title":"Annotations","text":"<p>When adding new annotations:</p> <ul> <li>Use PascalCase for annotation names</li> <li>Document the annotation's purpose and usage</li> <li>Add examples in the documentation</li> <li>Follow the existing annotation pattern:   <pre><code>// @Charm\n// @Title \"Your Feature Title\"\n// @Description \"A clear description of what your feature does\"\nfunc YourFeature() {\n    // Implementation\n}\n</code></pre></li> </ul>"},{"location":"contributing/#documentation-guidelines","title":"\ud83d\udcda Documentation Guidelines","text":""},{"location":"contributing/#writing-documentation","title":"Writing Documentation","text":"<ul> <li>Use clear, concise language</li> <li>Include code examples where appropriate</li> <li>Follow Markdown best practices</li> <li>Update the mkdocs configuration if adding new pages</li> <li>Test documentation locally using mkdocs:   <pre><code>mkdocs serve\n</code></pre></li> </ul>"},{"location":"contributing/#example-documentation-format","title":"Example Documentation Format","text":"<pre><code># Feature Name\n\n## Overview\n\nBrief description of the feature.\n\n## Usage\n\n    ```go\n    // Code example\n    ```\n\n## Parameters\n\n- `param1`: Description of first parameter\n- `param2`: Description of second parameter\n\n## Examples\n\nPractical examples of feature usage.\n</code></pre>"},{"location":"contributing/#reporting-issues","title":"\ud83d\udc1b Reporting Issues","text":"<p>When reporting issues, please include:</p> <ol> <li>Charmer version</li> <li>Go version</li> <li>Operating system</li> <li>Steps to reproduce</li> <li>Expected vs actual behavior</li> <li>Any relevant code snippets</li> <li>Error messages (if any)</li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"\ud83c\udfaf Pull Request Guidelines","text":"<p>Before Submitting:</p> <ul> <li>Ensure all tests pass</li> <li>Update documentation if needed</li> <li>Add tests for new features</li> <li>Follow code style guidelines</li> <li>Rebase on latest main branch</li> </ul> <p>PR Description:</p> <ul> <li>Clearly describe the changes</li> <li>Link to related issues</li> <li>Include screenshots for UI changes</li> <li>List breaking changes (if any)</li> </ul> <p>Review Process:</p> <ul> <li>Address review comments promptly</li> <li>Keep discussions focused and professional</li> <li>Update your PR as needed</li> </ul>"},{"location":"contributing/#recognition","title":"\ud83c\udf89 Recognition","text":"<p>Contributors will be: - Listed in the project's CONTRIBUTORS.md file - Mentioned in release notes for significant contributions - Credited in documentation where appropriate</p>"},{"location":"contributing/#getting-help","title":"\u2753 Getting Help","text":"<ul> <li>Check existing issues and discussions</li> <li>Reach out to maintainers</li> <li>Read through our Wiki (coming soon)</li> </ul>"},{"location":"contributing/#license-agreements","title":"\ud83d\udcdc License Agreements","text":"<ul> <li>All contributions must be licensed under GPL-3.0</li> <li>You must have the right to license your contribution</li> <li>Include copyright notices where appropriate</li> </ul> <p>Thank you for contributing to Charmer! Together, we can make terminal applications more beautiful and easier to create. \ud83c\udf1f</p> <p>For any questions not covered here, please open an issue or reach out to the maintainers.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Getting started with Charmer is straightforward. Follow these steps to set up Charmer in your Go project.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.24 or later</li> <li>A Go project where you want to implement a TUI</li> </ul>"},{"location":"getting-started/installation/#installing-charmer","title":"Installing Charmer","text":"<p>Add Charmer to your Go project using the <code>go get</code> command:</p> <pre><code>go get github.com/ImGajeed76/charmer@latest\n</code></pre> <p>Note: You maybe have to run <code>go mod tidy</code> to update your <code>go.mod</code> file after installing Charmer.</p> <p>This command fetches the latest version of Charmer and adds it to your project's dependencies.</p>"},{"location":"getting-started/installation/#setting-up-your-project","title":"Setting Up Your Project","text":""},{"location":"getting-started/installation/#1-update-your-maingo","title":"1. Update Your <code>main.go</code>","text":"<p>Create or update your <code>main.go</code> file to include the Charmer generator and runner:</p> <pre><code>//go:generate go run github.com/ImGajeed76/charmer/tools/generate\n\npackage main\n\nimport (\n    \"your-project/internal/registry\"\n    \"github.com/ImGajeed76/charmer/pkg/charmer\"\n)\n\nfunc main() {\n    charmer.Run(registry.RegisteredCharms)\n}\n</code></pre> <p>The <code>//go:generate</code> directive tells Go to run the Charmer code generator when you execute <code>go generate</code>.</p>"},{"location":"getting-started/installation/#2-create-your-first-charm","title":"2. Create Your First Charm","text":"<p>Create a directory called <code>charms</code> in your project root (if it doesn't exist already). This is where you'll place your charm functions:</p> <pre><code>mkdir -p charms\n</code></pre> <p>If you don't create this directory manually, the generator will create it for you with a sample charm.</p>"},{"location":"getting-started/installation/#3-run-the-generator","title":"3. Run the Generator","text":"<p>Execute the following command to generate the necessary code for your Charmer TUI:</p> <pre><code>go generate\n</code></pre> <p>This will:</p> <ul> <li>Create a registry for your charm functions</li> <li>Set up the navigation structure</li> <li>Generate all the necessary UI code</li> </ul>"},{"location":"getting-started/installation/#4-run-your-application","title":"4. Run Your Application","text":"<p>Now you can run your application:</p> <pre><code>go run main.go\n</code></pre> <p>Or build an executable:</p> <pre><code>go build\n./your-project\n</code></pre>"},{"location":"getting-started/installation/#verifying-the-installation","title":"Verifying the Installation","text":"<p>After running your application, you should see a beautiful terminal interface with navigation options. If you're seeing this, congratulations! Charmer is successfully installed and running.</p> <p>If you encounter any issues, check the troubleshooting section or open an issue on the GitHub repository.</p>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that you have Charmer installed, head over to the Quick Start guide to learn how to create your own custom charms.</p>"},{"location":"getting-started/project-structure/","title":"Project Structure","text":"<p>Understanding the recommended project structure for a Charmer application will help you organize your code efficiently. This guide explains how to structure your Go project to make the most of Charmer's capabilities.</p>"},{"location":"getting-started/project-structure/#basic-structure","title":"Basic Structure","text":"<p>A typical Charmer project follows this structure:</p> <pre><code>your-project/\n\u251c\u2500\u2500 main.go                       # Entry point with go:generate directive\n\u251c\u2500\u2500 go.mod                        # Go module definition\n\u251c\u2500\u2500 go.sum                        \n\u251c\u2500\u2500 charms/                       # Directory containing your charm functions\n\u2502   \u251c\u2500\u2500 greeting.go               \n\u2502   \u2514\u2500\u2500 Utilities                 # Optional: Subdirectories for organizing charms\n\u2502       \u2514\u2500\u2500 advanced.go               \n\u2514\u2500\u2500 internal/                     \n    \u2514\u2500\u2500 registry/                 \n        \u2514\u2500\u2500 generated.go          # Auto-generated registry of all your charms (do not edit)\n</code></pre>"},{"location":"getting-started/project-structure/#main-components","title":"Main Components","text":""},{"location":"getting-started/project-structure/#entry-point-maingo","title":"Entry Point (<code>main.go</code>)","text":"<p>The <code>main.go</code> file is the entry point of your application. It should include:</p> <ol> <li>The <code>go:generate</code> directive to run the Charmer code generator</li> <li>Import statements for your registry and Charmer package</li> <li>The <code>main()</code> function that runs your Charmer application</li> </ol> <pre><code>//go:generate go run github.com/ImGajeed76/charmer/tools/generate\n\npackage main\n\nimport (\n    \"your-project/internal/registry\"\n    \"github.com/ImGajeed76/charmer/pkg/charmer\"\n)\n\nfunc main() {\n    charmer.Run(registry.RegisteredCharms)\n}\n</code></pre>"},{"location":"getting-started/project-structure/#charms-directory","title":"Charms Directory","text":"<p>The <code>charms/</code> directory contains all your charm function files. Each file can contain multiple charm functions, but it's often helpful to organize related functions in the same file.</p> <pre><code>// charms/greeting.go\npackage charms\n\nimport \"fmt\"\n\n// SayHello godoc\n// @Charm\n// @Title Say Hello\n// @Description Displays a simple greeting\nfunc SayHello() {\n    fmt.Println(\"Hello, world!\")\n}\n\n// GreetUser godoc\n// @Charm\n// @Title Greet User\n// @Description Displays a personalized greeting with the user's name\nfunc GreetUser(name string) {\n    fmt.Printf(\"Hello, %s! Welcome to Charmer!\\n\", name)\n}\n</code></pre>"},{"location":"getting-started/project-structure/#generated-registry","title":"Generated Registry","text":"<p>When you run <code>go generate</code>, Charmer creates the registry directory and files automatically:</p> <pre><code>internal/registry/registry.go\n</code></pre> <p>This file contains the code that registers all your charm functions with the TUI system. You should not edit this file manually as it's regenerated each time you run <code>go generate</code>.</p>"},{"location":"getting-started/project-structure/#organization-strategies","title":"Organization Strategies","text":""},{"location":"getting-started/project-structure/#functional-organization","title":"Functional Organization","text":"<p>Organize your charm functions by feature or functionality:</p> <pre><code>charms/\n\u251c\u2500\u2500 user_management.go     # Functions related to user operations\n\u251c\u2500\u2500 data_processing.go     # Functions for data manipulation\n\u2514\u2500\u2500 system_utilities.go    # System-level utility operations\n</code></pre>"},{"location":"getting-started/project-structure/#directory-based-organization","title":"Directory-Based Organization","text":"<p>A powerful way to organize your charms is by using nested folders within the <code>charms/</code> directory. This creates a clean hierarchical structure in the TUI where the folder name becomes the category title:</p> <pre><code>charms/\n\u251c\u2500\u2500 User/                  # \"User\" category in the TUI\n\u2502   \u251c\u2500\u2500 create.go          # Functions for user creation\n\u2502   \u2514\u2500\u2500 manage.go          # Functions for user management\n\u251c\u2500\u2500 Network/               # \"Network\" category in the TUI\n\u2502   \u251c\u2500\u2500 diagnostics.go     # Network diagnostic functions\n\u2502   \u2514\u2500\u2500 config.go          # Network configuration functions\n\u2514\u2500\u2500 System/                # \"System\" category in the TUI\n    \u251c\u2500\u2500 monitor.go         # System monitoring functions\n    \u2514\u2500\u2500 maintenance.go     # System maintenance functions\n</code></pre> <p>With this approach, the TUI will first present the user with category selections (User, Network, System) and then show the specific functions within the selected category. This prevents the interface from becoming bloated with too many options at once, creating a cleaner, more navigable experience.</p>"},{"location":"getting-started/project-structure/#build-artifacts","title":"Build Artifacts","text":"<p>After building your Charmer application, you'll have a single executable that contains your entire TUI:</p> <pre><code>your-project  # Executable binary\n</code></pre> <p>This makes distribution simple - users only need the single binary file to run your application.</p>"},{"location":"getting-started/project-structure/#example-project-layout","title":"Example Project Layout","text":"<p>Here's a more complete example of a Charmer project structure:</p> <pre><code>my-cli-tool/\n\u251c\u2500\u2500 main.go\n\u251c\u2500\u2500 go.mod\n\u251c\u2500\u2500 go.sum\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 charms/\n\u2502   \u251c\u2500\u2500 System/                    # System category in the TUI\n\u2502   \u2502   \u251c\u2500\u2500 info.go                # System information commands\n\u2502   \u2502   \u2514\u2500\u2500 maintenance.go         # System maintenance commands\n\u2502   \u251c\u2500\u2500 Network/                   # Network category in the TUI\n\u2502   \u2502   \u251c\u2500\u2500 diagnostics.go         # Network diagnostic commands\n\u2502   \u2502   \u2514\u2500\u2500 configuration.go       # Network configuration commands\n\u2502   \u2514\u2500\u2500 Files/                     # Files category in the TUI\n\u2502       \u251c\u2500\u2500 operations.go          # File operation commands\n\u2502       \u2514\u2500\u2500 search.go              # File search commands\n\u251c\u2500\u2500 internal/\n\u2502   \u251c\u2500\u2500 registry/\n\u2502   \u2502   \u2514\u2500\u2500 registry.go\n\u2502   \u2514\u2500\u2500 helpers/\n\u2502       \u2514\u2500\u2500 common.go\n\u2514\u2500\u2500 docs/\n    \u2514\u2500\u2500 screenshots/\n        \u2514\u2500\u2500 demo.png\n</code></pre>"},{"location":"getting-started/project-structure/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Use descriptive annotations: Clear titles and descriptions make your TUI more user-friendly.</p> </li> <li> <p>Use folder organization for large applications: For applications with many commands, use the directory-based    organization to create logical categories and prevent UI clutter.</p> </li> <li> <p>Organize related functions: Group related functionality in the same file for better maintainability.</p> </li> <li> <p>Update generated code: Run <code>go generate</code> whenever you add, modify, or remove charm functions.</p> </li> <li> <p>Document your charms: Include detailed descriptions to help users understand what each function does.</p> </li> <li> <p>Balance menu depth: Avoid creating too many nested levels in directory structure nesting.</p> </li> <li> <p>Follow Go standards: Use standard Go naming conventions and code organization practices.</p> </li> </ol>"},{"location":"getting-started/quick-start/","title":"Quick Start Guide","text":"<p>This guide will walk you through creating your first Charmer-powered application with beautiful terminal UIs.</p>"},{"location":"getting-started/quick-start/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have:</p> <ul> <li>Installed Charmer as described in the Installation Guide</li> <li>A basic understanding of Go programming</li> </ul>"},{"location":"getting-started/quick-start/#creating-your-first-charm","title":"Creating Your First Charm","text":"<p>Let's create a simple greeting charm that asks for a user's name and displays a personalized greeting.</p>"},{"location":"getting-started/quick-start/#1-create-a-charm-file","title":"1. Create a Charm File","text":"<p>In your project's <code>charms</code> directory, create a new file called <code>greeting.go</code>:</p> <pre><code>package charms\n\nimport (\n    \"fmt\"\n    \"github.com/ImGajeed76/charmer/pkg/charmer/console\"\n)\n\n// Greeting godoc\n// @Charm\n// @Title Greeting\n// @Description\n// # Greeting\n// ## Description\n// This is a simple greeting function that asks for a name and greets the user.\nfunc Greeting() {\n    name, _ := console.Input(console.InputOptions{\n        Prompt: \"What is your name?\",\n    })\n\n    fmt.Printf(\"Hello, %s!\\n\", name)\n}\n</code></pre>"},{"location":"getting-started/quick-start/#2-generate-your-tui","title":"2. Generate Your TUI","text":"<p>Run the generator to create the TUI code:</p> <pre><code>go generate\n</code></pre>"},{"location":"getting-started/quick-start/#3-run-your-application","title":"3. Run Your Application","text":"<pre><code>go run main.go\n</code></pre> <p>You should now see a beautiful terminal interface with your Greeting charm. When selected, it will prompt for a name and display a greeting.</p>"},{"location":"getting-started/quick-start/#understanding-charm-annotations","title":"Understanding Charm Annotations","text":"<p>Charmer uses annotations to transform regular Go functions into interactive TUI elements:</p> <ul> <li><code>@Charm</code>: Marks a function to be included in the TUI</li> <li><code>@Title</code>: Sets the display title in the menu</li> <li><code>@Description</code>: Provides detailed information (supports Markdown)</li> </ul>"},{"location":"getting-started/quick-start/#multiline-descriptions","title":"Multiline Descriptions","text":"<p>As shown in the example, descriptions can span multiple lines and use Markdown:</p> <pre><code>// @Description\n// # Greeting\n// ## Description\n// This is a simple greeting function that asks for a name and greets the user.\n</code></pre> <p>This will be rendered beautifully in the TUI with proper formatting.</p>"},{"location":"getting-started/quick-start/#using-console-utilities","title":"Using Console Utilities","text":"<p>Charmer provides several utilities for terminal interaction in the <code>console</code> package:</p>"},{"location":"getting-started/quick-start/#text-input","title":"Text Input","text":"<p>The <code>Input</code> function provides a simple way to get text input from users:</p> <pre><code>// Simple usage\nvalue, err := console.Input()\n\n// With custom options\nname, err := console.Input(console.InputOptions{\nPrompt:      \"Enter your name:\",\nRegex:       \"^[a-zA-Z ]+$\",\nRegexError:  \"Please enter letters and spaces only\",\nDefault:     \"John\",\nPlaceholder: \"Enter name here\",\nRequired:    true,\n})\n</code></pre>"},{"location":"getting-started/quick-start/#selection-lists","title":"Selection Lists","text":"<p>For selecting from a list of options:</p> <pre><code>options := []string{\"Option 1\", \"Option 2\", \"Option 3\"}\n\n// Simple usage\nselectedIndex, err := console.ListSelect(options)\n\n// With custom title\nselectedIndex, err = console.ListSelect(options, console.ListSelectOptions{\nTitle: \"Choose your favorite:\",\n})\n</code></pre>"},{"location":"getting-started/quick-start/#yesno-confirmations","title":"Yes/No Confirmations","text":"<p>Get simple yes/no confirmations:</p> <pre><code>// Simple usage\nresult, err := console.YesNo()\n\n// Custom options\nresult, err = console.YesNo(console.YesNoOptions{\nPrompt:     \"Do you want to continue?\",\nDefaultYes: false,\nYesText:    \"Continue\",\nNoText:     \"Cancel\",\n})\n</code></pre>"},{"location":"getting-started/quick-start/#creating-a-hierarchical-menu","title":"Creating a Hierarchical Menu","text":"<p>You can organize your charms into hierarchical menus using the folder structure:</p>"},{"location":"getting-started/quick-start/#create-a-submenu","title":"Create a Submenu","text":"<ol> <li>Create a directory in your <code>charms</code> folder:</li> </ol> <pre><code>mkdir -p charms/Utils\n</code></pre> <ol> <li>Add charm functions to this directory:</li> </ol> <pre><code>// charms/Utils/calculator.go\npackage utils\n\nimport (\n    \"fmt\"\n    \"github.com/ImGajeed76/charmer/pkg/charmer/console\"\n    \"strconv\"\n)\n\n// Add godoc\n// @Charm\n// @Title Add Numbers\n// @Description Adds two numbers together\nfunc Add() {\n    num1Str, _ := console.Input(console.InputOptions{\n        Prompt: \"Enter first number:\",\n    })\n\n    num2Str, _ := console.Input(console.InputOptions{\n        Prompt: \"Enter second number:\",\n    })\n\n    num1, _ := strconv.ParseFloat(num1Str, 64)\n    num2, _ := strconv.ParseFloat(num2Str, 64)\n\n    fmt.Printf(\"Result: %.2f\\n\", num1+num2)\n}\n</code></pre> <ol> <li>Generate the TUI:</li> </ol> <pre><code>go generate\n</code></pre> <p>This will create a \"Utils\" submenu containing your \"Add Numbers\" charm.</p> <p>Folder Naming</p> <p>The folder name will be used as the submenu title. If your folder is named <code>Utils</code>, the submenu will be titled \"Utils\".</p> <p>Nested Submenus</p> <p>You can nest submenus as deep as you like by creating additional directories.</p> <p>Happy charming!</p>"},{"location":"guides/troubleshooting/","title":"Troubleshooting","text":"<p>No Troubleshooting Steps Available</p> <p>Currently there are no troubleshooting steps available. Please check the issues for help.</p>"},{"location":"reference/config-api/","title":"Charmer Configuration Manager","text":"<p>The Charmer Configuration Manager provides a secure way to store and manage configuration values using the system's native keyring/keychain. This documentation covers the complete API for the <code>config</code> package.</p>"},{"location":"reference/config-api/#overview","title":"Overview","text":"<p>The Configuration Manager uses the system's secure keyring (via zalando/go-keyring) to safely store sensitive configuration values. Each configuration instance is namespaced using a service name, allowing multiple applications or components to maintain separate configurations.</p>"},{"location":"reference/config-api/#installation","title":"Installation","text":"<p>The config package is included as part of Charmer:</p> <pre><code>import \"github.com/ImGajeed76/charmer/pkg/charmer/config\"\n</code></pre>"},{"location":"reference/config-api/#core-concepts","title":"Core Concepts","text":""},{"location":"reference/config-api/#service-names","title":"Service Names","text":"<p>Each Config instance is associated with a service name that acts as a namespace for stored values. This allows multiple applications to use the keyring without conflicts.</p>"},{"location":"reference/config-api/#keys-and-values","title":"Keys and Values","text":"<ul> <li>All values are stored as strings</li> <li>Empty keys are not allowed</li> <li>Keys must be unique within a service namespace</li> <li>Values can be empty strings</li> </ul>"},{"location":"reference/config-api/#api-reference","title":"API Reference","text":""},{"location":"reference/config-api/#creating-a-new-config-instance","title":"Creating a New Config Instance","text":"<pre><code>func New(service string) (*Config, error)\n</code></pre> <p>Creates a new configuration manager instance.</p> <p>Parameters:</p> <ul> <li><code>service</code> (string): The service name to namespace stored values</li> </ul> <p>Returns:</p> <ul> <li><code>*Config</code>: Configuration manager instance</li> <li><code>error</code>: Error if service name is empty</li> </ul> <p>Example: <pre><code>cfg, err := config.New(\"myapp\")\nif err != nil {\n    log.Fatal(err)\n}\n</code></pre></p>"},{"location":"reference/config-api/#setting-values","title":"Setting Values","text":""},{"location":"reference/config-api/#set","title":"Set","text":"<pre><code>func (c *Config) Set(key, value string) error\n</code></pre> <p>Stores a value in the keyring.</p> <p>Parameters:</p> <ul> <li><code>key</code> (string): The key to store the value under</li> <li><code>value</code> (string): The value to store</li> </ul> <p>Returns:</p> <ul> <li><code>error</code>: Error if key is empty or storage fails</li> </ul> <p>Example: <pre><code>err := cfg.Set(\"api_key\", \"secret123\")\n</code></pre></p>"},{"location":"reference/config-api/#setdefault","title":"SetDefault","text":"<pre><code>func (c *Config) SetDefault(key, value string) error\n</code></pre> <p>Stores a value only if the key doesn't already exist.</p> <p>Parameters:</p> <ul> <li><code>key</code> (string): The key to store the value under</li> <li><code>value</code> (string): The default value to store</li> </ul> <p>Returns:</p> <ul> <li><code>error</code>: Error if key is empty or storage fails</li> </ul> <p>Example: <pre><code>err := cfg.SetDefault(\"timeout\", \"30\")\n</code></pre></p>"},{"location":"reference/config-api/#setfrominput","title":"SetFromInput","text":"<pre><code>func (c *Config) SetFromInput(key string, options console.InputOptions) (string, error)\n</code></pre> <p>Prompts the user for input and stores the provided value.</p> <p>Parameters:</p> <ul> <li><code>key</code> (string): The key to store the value under</li> <li><code>options</code> (console.InputOptions): Input prompt configuration</li> </ul> <p>Returns:</p> <ul> <li><code>string</code>: The value entered by the user</li> <li><code>error</code>: Error if input collection or storage fails</li> </ul> <p>Example: <pre><code>value, err := cfg.SetFromInput(\"password\", console.InputOptions{\n    Prompt: \"Enter password: \"\n})\n</code></pre></p>"},{"location":"reference/config-api/#retrieving-values","title":"Retrieving Values","text":""},{"location":"reference/config-api/#get","title":"Get","text":"<pre><code>func (c *Config) Get(key string) string\n</code></pre> <p>Retrieves a value from the keyring.</p> <p>Parameters:</p> <ul> <li><code>key</code> (string): The key to retrieve</li> </ul> <p>Returns:</p> <ul> <li><code>string</code>: The stored value, or empty string if not found</li> </ul> <p>Example: <pre><code>apiKey := cfg.Get(\"api_key\")\n</code></pre></p>"},{"location":"reference/config-api/#exists","title":"Exists","text":"<pre><code>func (c *Config) Exists(key string) bool\n</code></pre> <p>Checks if a key exists in the keyring.</p> <p>Parameters:</p> <ul> <li><code>key</code> (string): The key to check</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code>: True if the key exists, false otherwise</li> </ul> <p>Example: <pre><code>if cfg.Exists(\"api_key\") {\n    // Key exists\n}\n</code></pre></p>"},{"location":"reference/config-api/#deleting-values","title":"Deleting Values","text":""},{"location":"reference/config-api/#delete","title":"Delete","text":"<pre><code>func (c *Config) Delete(key string) error\n</code></pre> <p>Removes a single value from the keyring.</p> <p>Parameters:</p> <ul> <li><code>key</code> (string): The key to remove</li> </ul> <p>Returns:</p> <ul> <li><code>error</code>: Error if key is empty or deletion fails</li> </ul> <p>Example: <pre><code>err := cfg.Delete(\"old_key\")\n</code></pre></p>"},{"location":"reference/config-api/#deleteall","title":"DeleteAll","text":"<pre><code>func (c *Config) DeleteAll() error\n</code></pre> <p>Removes all values stored under the service name.</p> <p>Returns:</p> <ul> <li><code>error</code>: Error if deletion fails</li> </ul> <p>Example: <pre><code>err := cfg.DeleteAll()\n</code></pre></p>"},{"location":"reference/config-api/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Service Names</p> <ul> <li>Use descriptive, unique service names</li> <li>Consider including version or environment information</li> <li>Example: <code>myapp-prod</code> or <code>myapp-v1</code></li> </ul> </li> <li> <p>Key Names</p> <ul> <li>Use consistent naming conventions</li> <li>Consider namespacing keys for different components</li> <li>Example: <code>db.password</code>, <code>api.key</code></li> </ul> </li> <li> <p>Error Handling</p> <ul> <li>Always check errors when setting values</li> <li>Consider providing fallback values when getting keys that might not exist</li> </ul> </li> </ol>"},{"location":"reference/config-api/#example-usage","title":"Example Usage","text":"<p>Here's a real-world example showing how to implement a global configuration manager for SFTP settings:</p> <pre><code>package config\n\nimport (\n    \"github.com/ImGajeed76/charmer/pkg/charmer/config\"\n    \"github.com/ImGajeed76/charmer/pkg/charmer/console\"\n    \"github.com/ImGajeed76/charmer/pkg/charmer/path\"\n    \"sync\"\n)\n\nvar (\n    globalCfg *config.Config\n    once      sync.Once\n)\n\nfunc InitConfig() {\n    once.Do(func() {\n        cfg, err := config.New(\"charmer-testing\")\n        if err != nil {\n            panic(err)\n        }\n        globalCfg = cfg\n    })\n\n    err := globalCfg.SetDefault(\"sftp-hostname\", \"myserver.com\")\n    if err != nil {\n        panic(err)\n    }\n\n    err = globalCfg.SetDefault(\"sftp-port\", \"22\")\n    if err != nil {\n        panic(err)\n    }\n\n    changeSettings, changeErr := console.YesNo(console.YesNoOptions{\n        Prompt:     \"Do you want to change the SFTP settings?\",\n        DefaultYes: false,\n        YesText:    \"Yes, change settings\",\n        NoText:     \"No, keep existing settings\",\n    })\n\n    if changeErr != nil {\n        panic(changeErr)\n    }\n\n    if changeSettings {\n        err = globalCfg.Delete(\"sftp-username\")\n        if err != nil {\n            return\n        }\n        err = globalCfg.Delete(\"sftp-password\")\n        if err != nil {\n            return\n        }\n    }\n\n    if !globalCfg.Exists(\"sftp-username\") {\n        _, usernameErr := globalCfg.SetFromInput(\"sftp-username\", console.InputOptions{\n            Prompt:   \"Enter the SFTP username\",\n            Required: true,\n        })\n        if usernameErr != nil {\n            panic(usernameErr)\n        }\n    }\n\n    if !globalCfg.Exists(\"sftp-password\") {\n        _, passwordErr := globalCfg.SetFromInput(\"sftp-password\", console.InputOptions{\n            Prompt: \"Enter the SFTP password (will be stored securely)\",\n        })\n        if passwordErr != nil {\n            panic(passwordErr)\n        }\n    }\n}\n\nfunc Cfg() *config.Config {\n    return globalCfg\n}\n\nfunc GetSFTPConfig() *path.SFTPConfig {\n    return &amp;path.SFTPConfig{\n        Host:     globalCfg.Get(\"sftp-hostname\"),\n        Port:     globalCfg.Get(\"sftp-port\"),\n        Username: globalCfg.Get(\"sftp-username\"),\n        Password: globalCfg.Get(\"sftp-password\"),\n    }\n}\n</code></pre>"},{"location":"reference/config-api/#error-handling","title":"Error Handling","text":"<p>The configuration manager returns errors in the following cases:</p> <ol> <li>Empty service name when creating a new instance</li> <li>Empty key when setting or deleting values</li> <li>System keyring access errors</li> <li>User input collection errors</li> </ol> <p>Always check returned errors and handle them appropriately in your application.</p>"},{"location":"reference/config-api/#limitations","title":"Limitations","text":"<ol> <li>Only string values are supported</li> <li>No built-in encryption (relies on system keyring security)</li> <li>No support for structured data (must be serialized/deserialized)</li> <li>Service names and keys must be non-empty strings</li> </ol>"},{"location":"reference/config-api/#related-documentation","title":"Related Documentation","text":"<ul> <li>Charmer Main Documentation</li> <li>Console Package Documentation</li> <li>Go Keyring Documentation</li> </ul>"},{"location":"reference/console-api/","title":"Charmer Console API Documentation","text":"<p>Charmer provides a set of utilities for interacting with the terminal in the <code>console</code> package. These utilities include functions for text input, list selection, progress bars, and binary yes/no confirmations.</p>"},{"location":"reference/console-api/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Overview</li> <li>YesNo Component</li> <li>Input Component</li> <li>ProgressBar Component</li> <li>ListSelect Component</li> </ol>"},{"location":"reference/console-api/#overview","title":"Overview","text":"<p>This API provides a set of tools that make it easier to use charmer. It includes functions for common terminal</p> <ul> <li>Binary yes/no confirmations</li> <li>Text input with validation</li> <li>Progress bars with customizable appearance</li> <li>List selection interfaces</li> </ul> <p>The API is built using the Charm libraries for terminal UI components.</p> <p>You are more than welcome to contribute to this API by adding more functions or improving the existing ones.</p>"},{"location":"reference/console-api/#yesno-component","title":"YesNo Component","text":"<p>The <code>YesNo</code> component provides a simple binary confirmation prompt.</p>"},{"location":"reference/console-api/#types","title":"Types","text":"<pre><code>type YesNoOptions struct {\n    Prompt     string\n    DefaultYes bool   // If true, \"Yes\" is pre-selected\n    YesText    string // Custom text for \"Yes\" option\n    NoText     string // Custom text for \"No\" option\n}\n</code></pre>"},{"location":"reference/console-api/#functions","title":"Functions","text":"<pre><code>func DefaultYesNoOptions() YesNoOptions\n</code></pre> <p>Returns default options for the YesNo component:</p> <ul> <li>Prompt: \"Confirm?\"</li> <li>DefaultYes: true</li> <li>YesText: \"Yes\"</li> <li>NoText: \"No\"</li> </ul> <pre><code>func YesNo(options ...YesNoOptions) (bool, error)\n</code></pre> <p>Displays a yes/no prompt and returns the user's selection as a boolean value.</p>"},{"location":"reference/console-api/#example-usage","title":"Example Usage","text":"<pre><code>package charms\n\nimport (\n    \"github.com/ImGajeed76/charmer/pkg/charmer/console\"\n)\n\n// myFunc godoc\n// @Charm\n// @Title myFunc\n// @Description This is a sample charm\nfunc myFunc() {\n    // Simple usage with defaults\n    result, _ := console.YesNo()\n\n    // Custom options\n    result, _ := console.YesNo(console.YesNoOptions{\n        Prompt:     \"Do you want to continue?\",\n        DefaultYes: false,\n        YesText:    \"Continue\",\n        NoText:     \"Cancel\",\n    })\n}\n</code></pre>"},{"location":"reference/console-api/#input-component","title":"Input Component","text":"<p>The <code>Input</code> component provides a text input field with optional validation.</p>"},{"location":"reference/console-api/#types_1","title":"Types","text":"<pre><code>type InputOptions struct {\n    Prompt      string\n    Regex       string\n    RegexError  string // Custom error message for regex validation\n    Default     string\n    Placeholder string\n    CharLimit   int\n    Width       int\n    Required    bool // If true, empty input is not allowed\n}\n</code></pre>"},{"location":"reference/console-api/#functions_1","title":"Functions","text":"<pre><code>func DefaultInputOptions() InputOptions\n</code></pre> <p>Returns default options for the Input component:</p> <ul> <li>Prompt: \"Enter value:\"</li> <li>CharLimit: 156</li> <li>Width: 20</li> <li>Required: false</li> <li>RegexError: \"Input format is invalid\"</li> </ul> <pre><code>func Input(options ...InputOptions) (string, error)\n</code></pre> <p>Displays a text input prompt and returns the user's input as a string.</p>"},{"location":"reference/console-api/#example-usage_1","title":"Example Usage","text":"<pre><code>package charms\n\nimport (\n    \"github.com/ImGajeed76/charmer/pkg/charmer/console\"\n)\n\n// myFunc godoc\n// @Charm\n// @Title myFunc\n// @Description This is a sample charm\nfunc myFunc() {\n    // Simple usage with defaults\n    value1, _ := console.Input()\n\n    // Custom options with validation\n    value2, _ := console.Input(console.InputOptions{\n        Prompt:      \"Enter your name:\",\n        Regex:       \"^[a-zA-Z ]+$\",\n        RegexError:  \"Please enter letters and spaces only\",\n        Default:     \"John\",\n        Placeholder: \"Enter name here\",\n        Required:    true,\n    })\n}\n</code></pre>"},{"location":"reference/console-api/#progressbar-component","title":"ProgressBar Component","text":"<p>The <code>ProgressBar</code> component provides a visual progress indicator with customizable appearance.</p>"},{"location":"reference/console-api/#types_2","title":"Types","text":"<pre><code>type ProgressOptions struct {\n    GradientColors []string\n    Width          int\n    Padding        int\n}\n\ntype ProgressBar struct {\n    Update func (total, count int64)\n    Close  func ()\n    Finish func ()\n}\n</code></pre>"},{"location":"reference/console-api/#functions_2","title":"Functions","text":"<pre><code>func DefaultProgressOptions() ProgressOptions\n</code></pre> <p>Returns default options for the ProgressBar component:</p> <ul> <li>GradientColors: []string{\"#5956e0\", \"#e86ef6\"}</li> <li>Width: 80</li> <li>Padding: 2</li> </ul> <pre><code>func NewProgressBar(opts ...ProgressOptions) *ProgressBar\n</code></pre> <p>Creates a new progress bar with the specified options.</p>"},{"location":"reference/console-api/#methods","title":"Methods","text":"<pre><code>func (p *ProgressBar) Update(total, count int64)\n</code></pre> <p>Updates the progress bar's current state. The <code>total</code> parameter represents the total units of work, and <code>count</code> represents the completed units.</p> <pre><code>func (p *ProgressBar) Close()\n</code></pre> <p>Closes the progress bar and cleans up resources.</p> <pre><code>func (p *ProgressBar) Finish()\n</code></pre> <p>Sets the progress to 100% and then closes the progress bar.</p>"},{"location":"reference/console-api/#example-usage_2","title":"Example Usage","text":"<pre><code>package charms\n\nimport (\n    \"github.com/ImGajeed76/charmer/pkg/charmer/console\"\n    \"time\"\n)\n\n// myFunc godoc\n// @Charm\n// @Title myFunc\n// @Description This is a sample charm\nfunc myFunc() {\n    // Create a progress bar with default options\n    progressBar := console.NewProgressBar()\n\n    // Update progress (e.g., in a loop)\n    for i := int64(0); i &lt;= 100; i++ {\n        progressBar.Update(100, i)\n        time.Sleep(50 * time.Millisecond)\n    }\n\n    // Finish the progress bar\n    progressBar.Finish()\n\n    // Or close it manually\n    // progressBar.Close()\n}\n</code></pre> <p>Usage in file operations</p> <p>The <code>Update</code> methode can also be provided to a CopyTo or MoveTo operation to show the progress of the operation.</p>"},{"location":"reference/console-api/#listselect-component","title":"ListSelect Component","text":"<p>The <code>ListSelect</code> component provides a selectable list of options.</p>"},{"location":"reference/console-api/#types_3","title":"Types","text":"<pre><code>type ListSelectOptions struct {\n    Title string\n}\n</code></pre>"},{"location":"reference/console-api/#functions_3","title":"Functions","text":"<pre><code>func DefaultListSelectOptions() ListSelectOptions\n</code></pre> <p>Returns default options for the ListSelect component:</p> <ul> <li>Title: \"Select an option:\"</li> </ul> <pre><code>func ListSelect(items []string, options ...ListSelectOptions) (int, error)\n</code></pre> <p>Displays a list of options and returns the selected index.</p>"},{"location":"reference/console-api/#example-usage_3","title":"Example Usage","text":"<pre><code>package charms\n\nimport (\n    \"fmt\"\n    \"github.com/ImGajeed76/charmer/pkg/charmer/console\"\n)\n\n// myFunc godoc\n// @Charm\n// @Title myFunc\n// @Description This is a sample charm\nfunc myFunc() {\n    options := []string{\"Option 1\", \"Option 2\", \"Option 3\"}\n\n    // Simple usage\n    selectedIndex, err := console.ListSelect(options)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Printf(\"Selected: %s\\n\", options[selectedIndex])\n\n    // With custom title\n    selectedIndex, err = console.ListSelect(options, console.ListSelectOptions{\n        Title: \"Choose your favorite:\",\n    })\n}\n</code></pre> <p>Documentation Errors</p> <p>If you find any errors or inconsistencies in this documentation, please report them by  creating an issue on the Charmer GitHub repository.  Your feedback helps improve the project for everyone!</p>"},{"location":"reference/path-api/","title":"Charmer Path API Documentation","text":"<p>The Path API is a powerful component of the Charmer project that provides a unified interface for file system operations across different storage types including local files, SFTP, and URLs. This API abstracts away the complexities of handling different storage backends, allowing for seamless operations regardless of where your files are stored.</p>"},{"location":"reference/path-api/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Creating Path Objects</li> <li>Path Properties</li> <li>File Operations</li> <li>Directory Operations</li> <li>Path Manipulation</li> <li>SFTP Operations</li> <li>URL Operations</li> <li>Error Handling</li> <li>Examples</li> </ul>"},{"location":"reference/path-api/#overview","title":"Overview","text":"<p>The Path API unifies file operations across different storage systems:</p> <ul> <li>Local files: Work with files on the local file system</li> <li>SFTP: Securely access remote files via SFTP</li> <li>URLs: Interact with web resources through HTTP/HTTPS URLs</li> </ul>"},{"location":"reference/path-api/#creating-path-objects","title":"Creating Path Objects","text":""},{"location":"reference/path-api/#newpath-string-parameter-sftpconfig-path","title":"<code>New(path string, parameter ...*SFTPConfig) *Path</code>","text":"<p>Creates a new Path object for the specified path.</p> <pre><code>// Create a local path\nlocalPath := path.New(\"/path/to/file.txt\")\n\n// Create an SFTP path with explicit configuration\nsftpConfig := &amp;path.SFTPConfig{\n    Host:     \"example.com\",\n    Port:     \"22\",\n    Username: \"user\",\n    Password: \"pass\",\n}\nsftpPath := path.New(\"/remote/path\", sftpConfig)\n\n// Create an SFTP path using URL format\nsftpUrlPath := path.New(\"sftp://user:pass@example.com:22/remote/path\")\n\n// Create an HTTP URL path\nurlPath := path.New(\"https://example.com/resource\")\n</code></pre>"},{"location":"reference/path-api/#cwd-path","title":"<code>Cwd() *Path</code>","text":"<p>Creates a new Path object for the current working directory.</p> <pre><code>cwd := path.Cwd()\n</code></pre>"},{"location":"reference/path-api/#path-properties","title":"Path Properties","text":""},{"location":"reference/path-api/#type-checking","title":"Type Checking","text":"<pre><code>// Check if the path is an SFTP path\nisSftp := path.IsSftp()\n\n// Check if the path is a URL\nisUrl := path.IsUrl()\n\n// Check if the path exists\nexists := path.Exists()\n\n// Check if the path is a directory\nisDir := path.IsDir()\n\n// Check if the path is a file\nisFile := path.IsFile()\n</code></pre>"},{"location":"reference/path-api/#path-information","title":"Path Information","text":"<pre><code>// Get the string representation of the path\npathStr := path.String()\n\n// Get the SFTP URL representation (if path is SFTP)\nsftpUrl := path.SftpPath()\n\n// Get the name component of the path (filename or last directory)\nname := path.Name()\n\n// Get the stem (filename without extension)\nstem := path.Stem()\n\n// Get the suffix (file extension without the dot)\nsuffix := path.Suffix()\n</code></pre>"},{"location":"reference/path-api/#file-operations","title":"File Operations","text":""},{"location":"reference/path-api/#reading-files","title":"Reading Files","text":"<pre><code>// Read file as text with specified encoding\ncontent, err := path.ReadText(\"utf8\")\n\n// Read file as bytes\nbytes, err := path.ReadBytes()\n</code></pre>"},{"location":"reference/path-api/#writing-files","title":"Writing Files","text":"<pre><code>// Write text to file with specified encoding\nerr := path.WriteText(\"Hello, world!\", \"utf8\")\n\n// Write bytes to file\nerr := path.WriteBytes([]byte{72, 101, 108, 108, 111})\n</code></pre>"},{"location":"reference/path-api/#file-information","title":"File Information","text":"<pre><code>// Get detailed file information\ninfo, err := path.Stat()\nif err == nil {\n    fmt.Printf(\"Name: %s\\n\", info.Name)\n    fmt.Printf(\"Size: %d bytes\\n\", info.Size)\n    fmt.Printf(\"Mode: %o\\n\", info.Mode)\n    fmt.Printf(\"Modified: %s\\n\", info.ModTime)\n    fmt.Printf(\"Is Directory: %t\\n\", info.IsDir)\n}\n</code></pre>"},{"location":"reference/path-api/#directory-operations","title":"Directory Operations","text":""},{"location":"reference/path-api/#listing-directory-contents","title":"Listing Directory Contents","text":"<pre><code>// List all items in a directory (non-recursive)\nitems, err := path.List()\n\n// List all items in a directory and subdirectories (recursive)\nallItems, err := path.ListRecursive()\n</code></pre>"},{"location":"reference/path-api/#creating-and-removing-directories","title":"Creating and Removing Directories","text":"<pre><code>// Create a directory\n// - parents: Create parent directories if they don't exist\n// - existsOk: Don't error if directory already exists\nerr := path.MakeDir(true, true)\n\n// Remove a directory\n// - missingOk: Don't error if directory doesn't exist\n// - recursive: Remove all contents recursively (if this is false, directory must be empty)\n// - followSymlinks: Follow symbolic links\nerr := path.RemoveDir(true, true, false)\n</code></pre>"},{"location":"reference/path-api/#finding-files-with-patterns","title":"Finding Files with Patterns","text":"<pre><code>// Find all paths matching a pattern\nmatches, err := path.Glob(\"*.txt\")\n</code></pre>"},{"location":"reference/path-api/#path-manipulation","title":"Path Manipulation","text":""},{"location":"reference/path-api/#path-transformation","title":"Path Transformation","text":"<pre><code>// Get parent directory\nparent := path.Parent()\n\n// Join paths\nnewPath := path.Join(\"subdir/file.txt\")\n\n// Make a copy of the Path object\npathCopy := path.Copy()\n\n// Set a new path for the Path object\nerr := path.SetPath(\"/new/path\")\n</code></pre>"},{"location":"reference/path-api/#file-operations_1","title":"File Operations","text":"<pre><code>// Rename a file\n// - newName: The new name for the file (not the full path)\n// - followSymlinks: Follow symbolic links\nerr := path.Rename(\"newfilename.txt\", false)\n\n// Remove a file\n// - missingOk: Don't error if file doesn't exist\n// - followSymlinks: Follow symbolic links (if true, this will remove the source of the symlink)\nerr := path.Remove(true, false)\n</code></pre>"},{"location":"reference/path-api/#copying-and-moving","title":"Copying and Moving","text":"<pre><code>// Copy to another path\npath1 := path.New(\"/source/path\")\npath2 := path.New(\"/destination/path\")\nerr := path1.CopyTo(path2)\n\n// Copy with options\noptions := pathmodels.CopyOptions{\n    PathOptions: pathmodels.DefaultPathOption(),\n    FollowSymlinks: true,\n    Recursive: true,\n}\nerr := path1.CopyTo(path2, options)\n\n// Move to another path (with overwrite option)\nerr := path1.MoveTo(path2, true)\n</code></pre>"},{"location":"reference/path-api/#sftp-operations","title":"SFTP Operations","text":""},{"location":"reference/path-api/#sftp-configuration","title":"SFTP Configuration","text":"<pre><code>// Get connection details for an SFTP path\nconn, err := path1.ConnectionDetails()\nif err == nil {\n    fmt.Printf(\"Host: %s\\n\", conn.Hostname)\n    fmt.Printf(\"Port: %d\\n\", conn.Port)\n    fmt.Printf(\"Username: %s\\n\", conn.Username)\n}\n</code></pre>"},{"location":"reference/path-api/#cross-system-operations","title":"Cross-System Operations","text":"<p>The API seamlessly handles operations between different storage systems:</p> <ul> <li>Local to Local</li> <li>Local to SFTP</li> <li>SFTP to Local</li> <li>SFTP to SFTP</li> <li>URL to Local</li> <li>URL to SFTP</li> </ul> <pre><code>// Copy from local to SFTP\nlocalPath := path.New(\"/local/file.txt\")\nsftpPath := path.New(\"sftp://user:pass@host:22/remote/file.txt\")\nerr := localPath.CopyTo(sftpPath)\n\n// Copy from SFTP to local\nerr := sftpPath.CopyTo(localPath)\n\n// Copy from URL to local (downloads the URL content)\nurlPath := path.New(\"https://example.com/resource\")\nerr := urlPath.CopyTo(localPath)\n</code></pre>"},{"location":"reference/path-api/#url-operations","title":"URL Operations","text":"<p>URLs have limited operations compared to local paths and SFTP paths. They support:</p> <ul> <li>Reading basic metadata via <code>Stat()</code></li> <li>Copying to local or SFTP paths via <code>CopyTo()</code></li> <li>Getting path components via <code>Name()</code>, <code>Parent()</code>, etc.</li> </ul> <p>In general, URLs are read-only and do not support write operations.</p> <pre><code>// Check if a URL exists\nurlPath := path.New(\"https://example.com/resource\")\nexists := urlPath.Exists()\n\n// Get URL metadata\ninfo, err := urlPath.Stat()\n\n// Download a URL to a local path\nlocalPath := path.New(\"/download/destination.file\")\nerr := urlPath.CopyTo(localPath)\n</code></pre>"},{"location":"reference/path-api/#error-handling","title":"Error Handling","text":"<p>The Path API uses a structured error system with the <code>pathmodels.PathError</code> type:</p> <pre><code>if err != nil {\n    if pathErr, ok := err.(*pathmodels.PathError); ok {\n        fmt.Printf(\"Operation: %s\\n\", pathErr.Op)\n        fmt.Printf(\"Path: %s\\n\", pathErr.Path)\n        fmt.Printf(\"Error: %s\\n\", pathErr.Err)\n    }\n}\n</code></pre> <p>Common error constants:</p> <ul> <li><code>pathmodels.ErrNotExist</code>: Path does not exist</li> <li><code>pathmodels.ErrExist</code>: Path already exists</li> </ul>"},{"location":"reference/path-api/#examples","title":"Examples","text":""},{"location":"reference/path-api/#working-with-local-files","title":"Working with Local Files","text":"<pre><code>// Create a new local path\nlocalPath := path.New(\"/tmp/example.txt\")\n\n// Write content to the file\nerr := localPath.WriteText(\"Hello, Charmer!\", \"utf8\")\nif err != nil {\n    log.Fatal(err)\n}\n\n// Read the file back\ncontent, err := localPath.ReadText(\"utf8\")\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Println(content)\n\n// Get file information\ninfo, err := localPath.Stat()\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Printf(\"File size: %d bytes\\n\", info.Size)\n\n// Create a directory\ndirPath := path.New(\"/tmp/charmer_example\")\nerr = dirPath.MakeDir(true, true)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Copy the file to the new directory\nnewPath := dirPath.Join(\"example_copy.txt\")\nerr = localPath.CopyTo(newPath)\nif err != nil {\n    log.Fatal(err)\n}\n\n// List files in the directory\nfiles, err := dirPath.List()\nif err != nil {\n    log.Fatal(err)\n}\nfor _, file := range files {\n    fmt.Println(file.String())\n}\n\n// Clean up\nerr = localPath.Remove(true, false)\nif err != nil {\n    log.Fatal(err)\n}\nerr = dirPath.RemoveDir(true, true, false)\nif err != nil {\n    log.Fatal(err)\n}\n</code></pre>"},{"location":"reference/path-api/#working-with-sftp","title":"Working with SFTP","text":"<pre><code>// Create an SFTP path\nsftpPath := path.New(\"sftp://user:pass@example.com:22/remote/example.txt\")\n\n// Check if the file exists\nif !sftpPath.Exists() {\n    // Create parent directories if needed\n    parentDir := sftpPath.Parent()\n    err := parentDir.MakeDir(true, true)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Write content to the file\n    err = sftpPath.WriteText(\"Hello from SFTP!\", \"utf8\")\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n\n// Read the file\ncontent, err := sftpPath.ReadText(\"utf8\")\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Println(content)\n\n// Copy the file locally\nlocalPath := path.New(\"/tmp/sftp_example.txt\")\nerr = sftpPath.CopyTo(localPath)\nif err != nil {\n    log.Fatal(err)\n}\n</code></pre>"},{"location":"reference/path-api/#working-with-urls","title":"Working with URLs","text":"<pre><code>// Create a URL path\nurlPath := path.New(\"https://example.com/index.html\")\n\n// Check if the URL exists\nif urlPath.Exists() {\n    // Download the URL content\n    localPath := path.New(\"/tmp/example_download.html\")\n    err := urlPath.CopyTo(localPath)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Read the downloaded content\n    content, err := localPath.ReadText(\"utf8\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf(\"Downloaded %d bytes\\n\", len(content))\n}\n</code></pre>"},{"location":"reference/path-api/#cross-platform-operations","title":"Cross-Platform Operations","text":"<pre><code>// Copy from a URL to an SFTP server\nurlPath := path.New(\"https://example.com/resource.zip\")\nsftpPath := path.New(\"sftp://user:pass@example.com:22/downloads/resource.zip\")\n\nerr := urlPath.CopyTo(sftpPath)\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Println(\"Successfully downloaded URL directly to SFTP server\")\n</code></pre>"},{"location":"reference/path-api/#path-validation","title":"Path Validation","text":"<p>The Path API includes built-in validation to ensure paths are well-formed and safe to use:</p> <pre><code>// Validate a path\npath := path.New(\"/some/path\")\nerr := path.Validate()\nif err != nil {\n    fmt.Printf(\"Invalid path: %s\\n\", err)\n}\n</code></pre> <p>Validation checks include:</p> <ul> <li>Path length limits</li> <li>Invalid characters</li> <li>Reserved names (on Windows)</li> <li>URL format validation</li> <li>SFTP host, port, and credential validation</li> </ul> <p>This validation helps prevent path-based security issues and ensures cross-platform compatibility.</p> <p>Auto Validation</p> <p>Path objects are automatically validated when created and when used in operations. This helps catch issues early and ensures that paths are safe to use in file operations.</p> <p>Documentation Errors</p> <p>If you find any errors or inconsistencies in this documentation, please report them by  creating an issue on the Charmer GitHub repository.  Your feedback helps improve the project for everyone!</p>"}]}