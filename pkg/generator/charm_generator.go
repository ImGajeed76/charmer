package generator

import (
	"fmt"
	"github.com/imgajeed76/charmer/pkg/doc_parser"
	"go/ast"
	"go/doc"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type CharmFunction struct {
	Name        string
	Doc         string
	Package     string
	Path        string
	Title       string
	Description string
}

type Import struct {
	Package    string
	ParentPath string
}

type RegistryData struct {
	Imports []Import
	Charms  []CharmFunction
}

const registryTemplate = `// Code generated by charm-generator; DO NOT EDIT.
package registry

import (
{{- range .Imports}}
    {{.Package}} "{{.ParentPath}}"
{{- end}}
    "github.com/imgajeed76/charmer/pkg/charmer"
)

var RegisteredCharms = map[string]charmer.CharmFunc{
{{- range .Charms}}
    "{{.Name}}": {
        Name:    "{{.Name}}",
        Doc:     ` + "`{{.Doc}}`" + `,
        Execute: {{.Package}}.{{.Name}},
		Path:    "{{.Path}}",
		Title:   "{{.Title}}",
		Description: ` + "`{{.Description}}`" + `,
    },
{{- end}}
}
`

func FindCharms(dir string, moduleRoot string) ([]CharmFunction, []Import, error) {
	var charms []CharmFunction
	importMap := make(map[string]Import)         // Using map to deduplicate
	usedModulePaths := make(map[string]struct{}) // Using map to deduplicate

	// Get module name from go.mod
	moduleData, err := os.ReadFile(filepath.Join(moduleRoot, "go.mod"))
	if err != nil {
		return nil, nil, fmt.Errorf("error reading go.mod: %v", err)
	}

	lines := strings.Split(string(moduleData), "\n")
	if len(lines) == 0 {
		return nil, nil, fmt.Errorf("empty go.mod file")
	}

	parts := strings.Fields(lines[0])
	if len(parts) != 2 || parts[0] != "module" {
		return nil, nil, fmt.Errorf("invalid go.mod format")
	}
	moduleName := parts[1]

	err = filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip directories in the walk
		if info.IsDir() {
			return nil
		}

		// Only process .go files
		if !strings.HasSuffix(path, ".go") {
			return nil
		}

		// Create a new file set
		fset := token.NewFileSet()

		// Parse the file (not directory)
		file, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			return fmt.Errorf("error parsing file %s: %v", path, err)
		}

		// Create package doc
		pkg := &ast.Package{
			Name:  file.Name.Name,
			Files: map[string]*ast.File{path: file},
		}
		docPkg := doc.New(pkg, "./", 0)

		// Look through all functions
		for _, fn := range docPkg.Funcs {
			if strings.Contains(fn.Doc, "@Charm") {
				// Parse docstring for annotations
				docs := doc_parser.ParseAnnotations(fn.Doc)

				// Get the parent directory path
				parentDir := filepath.Dir(path)

				// Get path relative to project root
				relPath, err := filepath.Rel(moduleRoot, parentDir)
				if err != nil {
					return fmt.Errorf("error getting relative path: %v", err)
				}

				// Combine with module name
				fullPath := filepath.Join(moduleName, relPath)
				// Convert to forward slashes for Go import path
				fullPath = filepath.ToSlash(fullPath)

				// Get the module path
				modulePath := strings.TrimPrefix(relPath, "charms")
				modulePath = strings.TrimPrefix(modulePath, "/")
				if modulePath != "" {
					modulePath += "/"
				}
				modulePath += strings.TrimSuffix(fn.Name, ".go")

				// If module path is already used, give a helpful error
				if _, ok := usedModulePaths[modulePath]; ok {
					return fmt.Errorf("duplicate charm module path '%s' detected. Each charm must have a unique module path. This can happen if:\n"+
						"1. You have multiple charm functions in different files but with the same directory structure and title\n"+
						"2. You have copied a charm file without renaming its @Title annotation\n\n"+
						"To fix this:\n"+
						"- Ensure each charm has a unique combination of directory location and @Title\n"+
						"- Check that charm files in different directories don't share the same @Title\n"+
						"- Consider adding a distinguishing prefix/suffix to the @Title if needed\n"+
						"- Verify the directory structure matches your intended module hierarchy",
						modulePath)
				}

				// Add to used module paths
				usedModulePaths[modulePath] = struct{}{}

				charm := CharmFunction{
					Name:        fn.Name,
					Doc:         strings.TrimSpace(fn.Doc),
					Package:     file.Name.Name,
					Path:        modulePath,
					Title:       docs.Title,
					Description: docs.Description,
				}
				charms = append(charms, charm)

				// Add to imports map
				importMap[file.Name.Name] = Import{
					Package:    file.Name.Name,
					ParentPath: fullPath,
				}
			}
		}

		return nil
	})

	if err != nil {
		return nil, nil, err
	}

	// Convert import map to slice
	imports := make([]Import, 0, len(importMap))
	for _, imp := range importMap {
		imports = append(imports, imp)
	}

	return charms, imports, nil
}

func GenerateRegistry(charms []CharmFunction, imports []Import) error {

	// Prepare template data
	data := RegistryData{
		Imports: imports,
		Charms:  charms,
	}

	// Create output directory if it doesn't exist
	err := os.MkdirAll("internal/registry", 0755)
	if err != nil {
		return fmt.Errorf("error creating registry directory: %v", err)
	}

	// Create the output file
	f, err := os.Create("internal/registry/generated.go")
	if err != nil {
		return fmt.Errorf("error creating generated file: %v", err)
	}
	defer func(f *os.File) {
		err := f.Close()
		if err != nil {
			log.Printf("error closing file: %v", err)
		}
	}(f)

	// Parse and execute the template
	tmpl, err := template.New("registry").Parse(registryTemplate)
	if err != nil {
		return fmt.Errorf("error parsing template: %v", err)
	}

	err = tmpl.Execute(f, data)
	if err != nil {
		return fmt.Errorf("error executing template: %v", err)
	}

	return nil
}

func Generate() {
	charms, imports, err := FindCharms("charms", "./")
	if err != nil {
		log.Fatal(err)
	}

	err = GenerateRegistry(charms, imports)
	if err != nil {
		log.Fatal(err)
	}

	log.Printf("Generated registry.go with %d charms\n", len(charms))
}
